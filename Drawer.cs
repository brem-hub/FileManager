using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace FileManager
{
    /* В данном классе использованы следующие, пока официально не изученные на лекциях структуры:
     *       
     *     enum - Перечисление (https://docs.microsoft.com/ru-ru/dotnet/api/system.enum?view=netcore-3.1)
     *    
     *     SortedDictionary - словарь, которых хранит элементы как пары (https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.sorteddictionary-2?view=netcore-3.1)
     *                       <ключ> : <значение>, значение можно получать как a["First_key"] = "First_value"
     *    
    */

    /// <summary>
    /// Class that is capable of drawing the game in Console.
    /// Contains all the methods for outputting data.
    /// </summary>
    class Drawer
    {
        // Instance is initiated with Russian locale, but can be initialized with English.
        private LanguageData _language = new LanguageData("rus");

        // Enum is used for easier saving of WIDTH and HEIGHT.
        // Usage: (uint)AppWidth returns 100.
        enum Sizes : uint
        {
            AppWidth = 100,
            AppHeight = 25
        }

        private static string FormatBytes(long bytes)
        {
            string[] suffix = { "B", "KB", "MB", "GB", "TB" };
            int i;
            double dblSByte = bytes;
            for (i = 0; i < suffix.Length && bytes >= 1024; i++, bytes /= 1024)
            {
                dblSByte = bytes / 1024.0;
            }

            return $"{dblSByte:0.##} {suffix[i]}";
        }

        /// <summary>
        /// Method generates line that looks like this: +-----------------------+
        ///                                             |<-  `width` dashes   ->|
        /// </summary>
        /// <param name="width"> The width of the line </param>
        private string generateLine(uint width)
        {
            string line = "";
            line += "+";
            line += string.Concat(Enumerable.Repeat("-", (int)width));
            line += "+";
            return line;
        }

        /// <summary>
        /// Method generates Dictionary, so it could be used in DrawSector
        /// </summary>
        /// <param name="startPoint"> First row</param>
        /// <param name="dataLines"> Data to print</param>
        /// <returns>
        ///     Dictionary: { "row_where_to_print" : "data_to_print"}
        /// </returns>
        private SortedDictionary<int, string> GenerateDictionaryOfDataLines(int startPoint, string[] dataLines)
        {
            SortedDictionary<int, string> data = new SortedDictionary<int, string>();
            int j = 0;
            for (int i = startPoint; i < dataLines.Length + startPoint; i++)
            {
                data.Add(i, dataLines[j]);
                j++;
            }
            return data;
        }

        /// <summary>
        /// Method generates empty string of size width
        /// </summary>
        /// <param name="width"> size of the string </param>
        /// <returns></returns>
        private string GenerateEmpty(uint width)
        {
            return string.Concat(Enumerable.Repeat(" ", (int)width));
        }
        
        /// <summary>
        /// Method prints the string of `width` spaces
        /// </summary>
        /// <param name="width"> The width of the line </param>
        private void DrawEmpty(uint width)
        {
            Console.Write(GenerateEmpty(width));
        }

        /// <summary>
        ///  Method prints an empty row: |                     |
        ///                              |<-  `width` spaces ->|
        /// </summary>
        /// <param name="width"> The width of the line </param>
        private void DrawEmptyRow(uint width)
        {
            Console.Write("|");
            DrawEmpty(width);
            Console.WriteLine("|");
        }

        /// <summary>
        ///    Method prints a line generated by generateLine() method
        /// </summary>
        /// <param name="width"> The width of the line </param>
        private void DrawLine(uint width)
        {
            Console.WriteLine(generateLine(width));
        }

       
        private uint MaxStringSize(string[] strings, string fileName = null)
        {
            uint max = (uint)strings[0].Length;
            foreach (var s in strings)
            {
                if (s.Length > max)
                    max = (uint)s.Length;
            }

            if (max % 2 != 0)
                max += 1;
            if (fileName != null)
            {
                max = (uint)Math.Max(max, fileName.Length);
                max += max % 2 == 0 ? 0u : 1u;
            }
            return max;
        }

        /// <summary>
        /// Method generates string with data placed in the middle
        ///     of the generated string.
        /// </summary>
        /// <param name="width"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        private string GenerateStringWithData(uint width, string data)
        {
            if (data.Length >= width)
            {
                return data;
            }
            string resData = "";
            int left = (int)width / 2 - data.Length / 2;
            int extra = data.Length % 2 == 0 ? 0 : 1;
            int right = Math.Max((int)width / 2 - data.Length / 2 - extra, 0);

            resData += "|";
            resData += GenerateEmpty((uint)left);
            resData += data;
            resData += GenerateEmpty((uint)right) + "|";

            return resData;
        }
        
        /// <summary>
        /// Method prints data in the middle of the screen
        ///     It calculates distance from left side to the begining of the data to output
        ///       and then prints data like this: "|             data_string            |"
        ///                                        |<-  left  ->|           |<- right ->|
        /// </summary>
        /// <param name="width"> The width of the row</param>
        /// <param name="data"> data string to print</param>
        private void DrawData(uint width, string data)
        {
            Console.WriteLine(GenerateStringWithData(width, data));
        }

        /// <summary>
        /// The most important method, that prints all the data in the Console.
        /// </summary>
        /// <param name="height"> height of the Sector</param>
        /// <param name="width"> width of the Sector</param>
        /// <param name="data"> data as distionary </param>
        private void DrawSector(uint height = (uint)Sizes.AppHeight, uint width = (uint)Sizes.AppWidth, SortedDictionary<int, string> data = null)
        {
            DrawLine(width);
            if (data == null)
            {
                for (int i = 0; i < height; i++)
                {
                    DrawEmptyRow((uint)Sizes.AppWidth);
                }
            }
            else
            {
                for (int i = 0; i < height; i++)
                {
                    if (data.ContainsKey(i))
                        DrawData(width, data[i]);
                    else
                        DrawEmptyRow((uint)Sizes.AppWidth);
                }
            }
            DrawLine(width);
        }

        /// <summary>
        /// Method adds menu at the left part of the screen.
        /// </summary>
        /// <param name="height"> height of menu </param>
        /// <param name="width"> width of the menu !!!can be only % 2!!!
        ///                                        !!!should never be less than size of any string inside menu!!! </param>
        /// <param name="startingPoint"> from what line to start drawing menu </param>
        /// <param name="menuData"> strings in menu </param>
        /// <param name="data"> main data dict </param>
        private void DrawLeftMenu(uint height, uint width, uint startingPoint, List<string> menuData, ref SortedDictionary<int, string> data)
        {
            /*TODO: now DrawLeftMenu can only draw menu with width Sizes.WIDTH
              TODO: check lines 250, 276 - change it to custom */

            var keys = new List<int>(data.Keys);
            foreach (var key in keys)
            {
                data[key] = GenerateStringWithData((uint)Sizes.AppWidth, data[key]);
            }

            // Iteration over menuData.
            int menuIterator = 0;

            bool drawCheck = false;

            for (int lineCounter = 1; lineCounter <= (uint)Sizes.AppHeight; lineCounter++)
            {
                if (lineCounter == startingPoint + height || lineCounter == startingPoint)
                {
                    drawCheck = !drawCheck;
                    // If line has any prerendered data - append our menu.
                    if (data.ContainsKey(lineCounter))
                    {
                        data[lineCounter] = data[lineCounter].Remove(0, (int)width + 2);
                        data[lineCounter] = data[lineCounter].Insert(0, generateLine(width));
                    }
                    // If line is empty - create new line with spaces. 
                    else
                    {
                        string line = generateLine(width)
                                      + string.Concat(Enumerable.Repeat(" ", (int)((uint)Sizes.AppWidth - width) - 1))
                                      + "|";
                        data.Add(lineCounter, line);
                    }
                    if (lineCounter == startingPoint + height)
                        break;
                }
                else if (drawCheck)
                {
                    if (data.ContainsKey(lineCounter))
                    {
                        data[lineCounter] = data[lineCounter].Remove(0, (int)width + 2);
                        // If any menu strings left to add.
                        if (menuIterator < menuData.Count)
                            data[lineCounter] = data[lineCounter].Insert(0,
                                GenerateStringWithData(width, menuData[menuIterator++]));
                        else
                            data[lineCounter] = data[lineCounter].Insert(0, "|" + GenerateEmpty(width)
                                + "|");
                    }
                    else
                    {
                        if (menuIterator < menuData.Count)
                        {
                            string control = GenerateStringWithData(width, menuData[menuIterator++]);
                            control += GenerateEmpty((uint)Sizes.AppWidth - width - 1) + "|";
                            data.Add(lineCounter, GenerateStringWithData((uint)Sizes.AppWidth, control));
                        }
                        else
                            data.Add(lineCounter, "|" + GenerateEmpty(width)
                                + "|" + GenerateEmpty((uint)Sizes.AppWidth - width - 1) + "|");
                    }
                }

            }
        }


        /// <summary>
        /// Sets LanguageData variable to the chosen _language 
        /// </summary>
        /// <param name="language"> "rus" or "eng" </param>
        public void SetLanguage(string language)
        {
            this._language = new LanguageData(language);
        }

        // Down here all the methods that just take generated data and print it using drawSector.
        //  !!! They don't calculate anything for the file manager, just output the data!!!
        public void DrawEndingScreen()
        {
            Console.Clear();
            SortedDictionary<int, string> data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2, _language.Ending());
            DrawSector(data: data);
        }

        public void DrawMainMenu()
        {
            Console.Clear();
            SortedDictionary<int, string> data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2, _language.Menu());
            DrawSector(data: data);
        }

        public void DrawIntro()
        {
            Console.Clear();
            string[] lines =
            {
                "Выберите язык / Choose _language", "[1] - Русский [2] - English",
                "Нажмите любую другую клавишу для выхода"
            };
            SortedDictionary<int, string>
                data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2, lines);
            DrawSector(data: data);
        }

        public void DrawInstruction()
        {
            Console.Clear();
            var lines = _language.DrawInstruction();
            var data = GenerateDictionaryOfDataLines(1, lines);
            data[6] = generateLine((uint) Sizes.AppWidth);
            DrawSector(data: data);
            Console.ReadKey(true);
        }
        public void DrawDriveChooser(DriveInfo[] info)
        {
            Console.Clear();
            string[] lines = new string[info.Length];
            for (int i = 0; i < info.Length; i++)
            {
                //TODO: move this string to LanguageData.
                lines[i] = _language.DiskData(i, info[i].Name, FormatBytes(info[i].TotalSize));
            }
            SortedDictionary<int, string>
                data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2, lines);

            string[] col = _language.DiskChooseLeftMenu();
            DrawLeftMenu(3, MaxStringSize(col) + 4, 1, new List<string>(col), ref data);
            DrawSector(data: data);
        }

        public void DrawDirFileSelection(List<Item> items, DirectoryInfo curDir, string copyFile = null, string moveFile = null, string concFile = null)
        {
            Console.Clear();
            var lines = GenerateItemLines(items);
            var data = GenerateDictionaryOfDataLines(5, lines);
            var dirData = new List<string> { curDir.FullName };
            var menuData = new List<string>(_language.DirFileMenu());

            const uint leftControlMenuStart = 5;
            const uint leftControlMenuHeight = 12;
            const uint additionalInfoStart = leftControlMenuStart + leftControlMenuHeight + 2;

            DrawLeftMenu(2, MaxStringSize(dirData.ToArray()) + 2, 1, dirData, ref data);
            DrawLeftMenu(leftControlMenuHeight, 28, leftControlMenuStart, menuData, ref data);

            DrawAdditionalMenu(copyFile, moveFile, concFile, additionalInfoStart, ref data);

            if (data.Count + 2 > (uint)Sizes.AppHeight)
                DrawSector((uint)data.Count + 2, data: data);
            else
                DrawSector(data: data);
        }

        private string[] GenerateItemLines(List<Item> items)
        {
            var lines = new string[items.Count];
            int i = 0;
            foreach (var item in items)
            {
                if (item.Active)
                {
                    if (!item.IsFile)
                        lines[i++] = "* " + item.Content + " " + _language.Directory();
                    else
                        lines[i++] = "* " + item.Content + " " + _language.File();
                }
                else
                {
                    if (!item.IsFile)
                        lines[i++] = item.Content + " " + _language.Directory();
                    else
                        lines[i++] = item.Content + " " + _language.File();
                }
            }

            return lines;
        }

        private void DrawAdditionalMenu(string copyFile, string moveFile, string concFile, uint additionalInfoStart,
           ref SortedDictionary<int, string> data)
        {
            List<string> menuData;
            if (copyFile != null)
            {
                uint extra = (uint) (copyFile.Length % 2 == 0 ? 0 : 1);
                menuData = new List<string>(_language.CopiedFile(copyFile));
                DrawLeftMenu(3, MaxStringSize(menuData.ToArray()), additionalInfoStart, menuData, ref data);
            }

            if (moveFile != null)
            {
                uint extra = (uint) (moveFile.Length % 2 == 0 ? 0 : 1);
                menuData = new List<string>(_language.MovedFile(moveFile));
                DrawLeftMenu(3, MaxStringSize(menuData.ToArray()), additionalInfoStart, menuData, ref data);
            }

            if (concFile != null)
            {
                uint extra = (uint) (concFile.Length % 2 == 0 ? 0 : 1);
                menuData = new List<string>(_language.ConcFile(concFile));
                DrawLeftMenu(3, MaxStringSize(menuData.ToArray()) + 2, additionalInfoStart, menuData, ref data);
            }
        }

        public void DrawTextFile(string[] lines, string fileName)
        {
            Console.Clear();

            var data = new SortedDictionary<int, string> { { 0, fileName } };
            DrawSector(1, MaxStringSize(lines, fileName), data);
            foreach (var line in lines)
            {
                Console.WriteLine(line);
            }
            Console.ReadKey(true);
        }

        public void DrawNewFileNameChoose()
        {
            Console.Clear();
            string[] lines = _language.NewFileName();
            var data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2, lines);
            DrawSector(data: data);
        }

        public void DrawAddText(string fileName, string text)
        {
            Console.Clear();
            var data = new SortedDictionary<int, string> { { 0, fileName } };
            var menuData = new List<string>(_language.AddTextData());
            DrawLeftMenu(3, MaxStringSize(menuData.ToArray()), 1, menuData, ref data);

            DrawSector(4, 100, data);
            if (text != "")
                Console.Write(text);
        }
        public void DrawError(Exception e, string fileName)
        {
            Console.Clear();
            string[] message;

            if (e.GetType() == typeof(UnauthorizedAccessException))
                message = _language.UnauthorizedAccessE(fileName);
            else if (e.GetType() == typeof(DirectoryNotFoundException))
                message = _language.DirectoryNotFoundE(fileName);
            else if (e.GetType() == typeof(ExtensionException))
                message = _language.ExtensionE(fileName);
            else if (e.GetType() == typeof(CopyFolderException))
                message = _language.MoveFolderE(fileName);
            else if (e.GetType() == typeof(FolderFileException))
                message = _language.FolderFileE(fileName);
            else if (e.Message == "copy")
                message = _language.OperationCopyE();
            else if (e.Message == "move")
                message = _language.OperationMoveE();
            else if (e.Message == "conc")
                message = _language.OperationConcE();
            else
                message = _language.PlugE(e.Message);
            var data = GenerateDictionaryOfDataLines((int)(uint)Sizes.AppHeight / 2,
                                                                         message);
            DrawSector(data: data);
            Console.ReadKey(true);
        }

        public void DrawChangeEncoding(string encoding)
        {
            Console.Clear();
            var data = GenerateDictionaryOfDataLines(1, _language.ChooseEncoding());
            int center = (int)(uint)Sizes.AppHeight / 2;
            data.Add(center, "[1] UTF-8");
            data.Add(center + 1, "[2] ASCII");
            data.Add(center + 2, "[3] Unicode");
            data.Add(center + 3, "[4] UTF-32");
            data.Add(center + 10, "[Esc] " + _language.Exit());
            var menuData = new List<string>() { _language.CurrentEncoding(), encoding };
            DrawLeftMenu(3, 20, 3, menuData, ref data);
            DrawSector(data: data);
        }

        public void DrawCopyOk(string fileName)
        {
            Console.Clear();
            var data = GenerateDictionaryOfDataLines(3, _language.DrawCopyOk(fileName));
            DrawSector(data: data);
            Console.ReadKey(true);
        }

        public void DrawMoveOk(string fileName)
        {
            Console.Clear();
            var data = GenerateDictionaryOfDataLines(3, _language.DrawMoveOk(fileName));
            DrawSector(data: data);
            Console.ReadKey(true);
        }

        public void DrawConcOk(string fileName)
        {
            Console.Clear();
            var data = GenerateDictionaryOfDataLines(3, _language.DrawConcOk(fileName));
            DrawSector(data: data);
            Console.ReadKey(true);
        }
        public void DrawDeleteOk(string fileName)
        {
            Console.Clear();
            var data = GenerateDictionaryOfDataLines(3, _language.DrawDeleteOk(fileName));
            DrawSector(data: data);
            Console.ReadKey(true);
        }
    }
}
